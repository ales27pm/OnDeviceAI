/**
 * This code was generated by [react-native-codegen](https://www.npmjs.com/package/react-native-codegen).
 *
 * Do not edit this file as changes may cause incorrect behavior and will be lost
 * once the code is regenerated.
 *
 * @generated by codegen project: GenerateModuleH.js
 */

#pragma once

#include <ReactCommon/TurboModule.h>
#include <react/bridging/Bridging.h>

namespace facebook::react {


  
#pragma mark - NativeCalendarCalendarEvent

template <typename P0, typename P1, typename P2>
struct NativeCalendarCalendarEvent {
  P0 id;
  P1 title;
  P2 start;
  bool operator==(const NativeCalendarCalendarEvent &other) const {
    return id == other.id && title == other.title && start == other.start;
  }
};

template <typename T>
struct NativeCalendarCalendarEventBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.id)>(rt, value.getProperty(rt, "id"), jsInvoker),
      bridging::fromJs<decltype(types.title)>(rt, value.getProperty(rt, "title"), jsInvoker),
      bridging::fromJs<decltype(types.start)>(rt, value.getProperty(rt, "start"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String idToJs(jsi::Runtime &rt, decltype(types.id) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String titleToJs(jsi::Runtime &rt, decltype(types.title) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String startToJs(jsi::Runtime &rt, decltype(types.start) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "id", bridging::toJs(rt, value.id, jsInvoker));
    result.setProperty(rt, "title", bridging::toJs(rt, value.title, jsInvoker));
    result.setProperty(rt, "start", bridging::toJs(rt, value.start, jsInvoker));
    return result;
  }
};

class JSI_EXPORT NativeCalendarCxxSpecJSI : public TurboModule {
protected:
  NativeCalendarCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual jsi::Value requestPermission(jsi::Runtime &rt) = 0;
  virtual jsi::Value createEvent(jsi::Runtime &rt, jsi::String title, jsi::String isoDate, std::optional<jsi::String> location) = 0;
  virtual jsi::Value listEvents(jsi::Runtime &rt, jsi::String isoDate) = 0;
  virtual jsi::Value updateEvent(jsi::Runtime &rt, jsi::String eventId, jsi::String title, jsi::String isoDate, std::optional<jsi::String> location) = 0;
  virtual jsi::Value deleteEvent(jsi::Runtime &rt, jsi::String eventId) = 0;
  virtual jsi::Value getPermissionStatus(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeCalendarCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "CalendarModule";

protected:
  NativeCalendarCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeCalendarCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeCalendarCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeCalendarCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    jsi::Value requestPermission(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::requestPermission) == 1,
          "Expected requestPermission(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::requestPermission, jsInvoker_, instance_);
    }
    jsi::Value createEvent(jsi::Runtime &rt, jsi::String title, jsi::String isoDate, std::optional<jsi::String> location) override {
      static_assert(
          bridging::getParameterCount(&T::createEvent) == 4,
          "Expected createEvent(...) to have 4 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::createEvent, jsInvoker_, instance_, std::move(title), std::move(isoDate), std::move(location));
    }
    jsi::Value listEvents(jsi::Runtime &rt, jsi::String isoDate) override {
      static_assert(
          bridging::getParameterCount(&T::listEvents) == 2,
          "Expected listEvents(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::listEvents, jsInvoker_, instance_, std::move(isoDate));
    }
    jsi::Value updateEvent(jsi::Runtime &rt, jsi::String eventId, jsi::String title, jsi::String isoDate, std::optional<jsi::String> location) override {
      static_assert(
          bridging::getParameterCount(&T::updateEvent) == 5,
          "Expected updateEvent(...) to have 5 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::updateEvent, jsInvoker_, instance_, std::move(eventId), std::move(title), std::move(isoDate), std::move(location));
    }
    jsi::Value deleteEvent(jsi::Runtime &rt, jsi::String eventId) override {
      static_assert(
          bridging::getParameterCount(&T::deleteEvent) == 2,
          "Expected deleteEvent(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::deleteEvent, jsInvoker_, instance_, std::move(eventId));
    }
    jsi::Value getPermissionStatus(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getPermissionStatus) == 1,
          "Expected getPermissionStatus(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getPermissionStatus, jsInvoker_, instance_);
    }

  private:
    friend class NativeCalendarCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};


  
#pragma mark - NativeSpeechModuleSpeechOptions

template <typename P0, typename P1, typename P2, typename P3>
struct NativeSpeechModuleSpeechOptions {
  P0 voiceId;
  P1 rate;
  P2 pitch;
  P3 volume;
  bool operator==(const NativeSpeechModuleSpeechOptions &other) const {
    return voiceId == other.voiceId && rate == other.rate && pitch == other.pitch && volume == other.volume;
  }
};

template <typename T>
struct NativeSpeechModuleSpeechOptionsBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.voiceId)>(rt, value.getProperty(rt, "voiceId"), jsInvoker),
      bridging::fromJs<decltype(types.rate)>(rt, value.getProperty(rt, "rate"), jsInvoker),
      bridging::fromJs<decltype(types.pitch)>(rt, value.getProperty(rt, "pitch"), jsInvoker),
      bridging::fromJs<decltype(types.volume)>(rt, value.getProperty(rt, "volume"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String voiceIdToJs(jsi::Runtime &rt, decltype(types.voiceId) value) {
    return bridging::toJs(rt, value);
  }

  static double rateToJs(jsi::Runtime &rt, decltype(types.rate) value) {
    return bridging::toJs(rt, value);
  }

  static double pitchToJs(jsi::Runtime &rt, decltype(types.pitch) value) {
    return bridging::toJs(rt, value);
  }

  static double volumeToJs(jsi::Runtime &rt, decltype(types.volume) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    if (value.voiceId) {
      result.setProperty(rt, "voiceId", bridging::toJs(rt, value.voiceId.value(), jsInvoker));
    }
    if (value.rate) {
      result.setProperty(rt, "rate", bridging::toJs(rt, value.rate.value(), jsInvoker));
    }
    if (value.pitch) {
      result.setProperty(rt, "pitch", bridging::toJs(rt, value.pitch.value(), jsInvoker));
    }
    if (value.volume) {
      result.setProperty(rt, "volume", bridging::toJs(rt, value.volume.value(), jsInvoker));
    }
    return result;
  }
};



#pragma mark - NativeSpeechModuleSpeechVoice

template <typename P0, typename P1, typename P2, typename P3, typename P4>
struct NativeSpeechModuleSpeechVoice {
  P0 id;
  P1 name;
  P2 language;
  P3 quality;
  P4 gender;
  bool operator==(const NativeSpeechModuleSpeechVoice &other) const {
    return id == other.id && name == other.name && language == other.language && quality == other.quality && gender == other.gender;
  }
};

template <typename T>
struct NativeSpeechModuleSpeechVoiceBridging {
  static T types;

  static T fromJs(
      jsi::Runtime &rt,
      const jsi::Object &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    T result{
      bridging::fromJs<decltype(types.id)>(rt, value.getProperty(rt, "id"), jsInvoker),
      bridging::fromJs<decltype(types.name)>(rt, value.getProperty(rt, "name"), jsInvoker),
      bridging::fromJs<decltype(types.language)>(rt, value.getProperty(rt, "language"), jsInvoker),
      bridging::fromJs<decltype(types.quality)>(rt, value.getProperty(rt, "quality"), jsInvoker),
      bridging::fromJs<decltype(types.gender)>(rt, value.getProperty(rt, "gender"), jsInvoker)};
    return result;
  }

#ifdef DEBUG
  static jsi::String idToJs(jsi::Runtime &rt, decltype(types.id) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String nameToJs(jsi::Runtime &rt, decltype(types.name) value) {
    return bridging::toJs(rt, value);
  }

  static jsi::String languageToJs(jsi::Runtime &rt, decltype(types.language) value) {
    return bridging::toJs(rt, value);
  }

  static double qualityToJs(jsi::Runtime &rt, decltype(types.quality) value) {
    return bridging::toJs(rt, value);
  }

  static double genderToJs(jsi::Runtime &rt, decltype(types.gender) value) {
    return bridging::toJs(rt, value);
  }
#endif

  static jsi::Object toJs(
      jsi::Runtime &rt,
      const T &value,
      const std::shared_ptr<CallInvoker> &jsInvoker) {
    auto result = facebook::jsi::Object(rt);
    result.setProperty(rt, "id", bridging::toJs(rt, value.id, jsInvoker));
    result.setProperty(rt, "name", bridging::toJs(rt, value.name, jsInvoker));
    result.setProperty(rt, "language", bridging::toJs(rt, value.language, jsInvoker));
    if (value.quality) {
      result.setProperty(rt, "quality", bridging::toJs(rt, value.quality.value(), jsInvoker));
    }
    if (value.gender) {
      result.setProperty(rt, "gender", bridging::toJs(rt, value.gender.value(), jsInvoker));
    }
    return result;
  }
};

class JSI_EXPORT NativeSpeechModuleCxxSpecJSI : public TurboModule {
protected:
  NativeSpeechModuleCxxSpecJSI(std::shared_ptr<CallInvoker> jsInvoker);

public:
  virtual void addListener(jsi::Runtime &rt, jsi::String eventName) = 0;
  virtual void removeListeners(jsi::Runtime &rt, double count) = 0;
  virtual jsi::Value requestSpeechRecognitionAuthorization(jsi::Runtime &rt) = 0;
  virtual jsi::Value startRecognition(jsi::Runtime &rt, jsi::String locale, bool requiresOnDeviceRecognition) = 0;
  virtual jsi::Value stopRecognition(jsi::Runtime &rt) = 0;
  virtual jsi::Value destroyRecognizer(jsi::Runtime &rt) = 0;
  virtual jsi::Value isRecognitionAvailable(jsi::Runtime &rt) = 0;
  virtual jsi::Value getSupportedLocales(jsi::Runtime &rt) = 0;
  virtual jsi::Value getAvailableVoices(jsi::Runtime &rt) = 0;
  virtual jsi::Value speak(jsi::Runtime &rt, jsi::String text, jsi::Object options) = 0;
  virtual jsi::Value stopSpeaking(jsi::Runtime &rt) = 0;
  virtual jsi::Value pauseSpeaking(jsi::Runtime &rt) = 0;
  virtual jsi::Value resumeSpeaking(jsi::Runtime &rt) = 0;
  virtual jsi::Value isSpeaking(jsi::Runtime &rt) = 0;
  virtual jsi::Value isPaused(jsi::Runtime &rt) = 0;
  virtual jsi::Value setDefaultVoice(jsi::Runtime &rt, jsi::String voiceId) = 0;
  virtual jsi::Value configureAudioSession(jsi::Runtime &rt) = 0;
  virtual jsi::Value releaseAudioSession(jsi::Runtime &rt) = 0;
  virtual jsi::Value getVersion(jsi::Runtime &rt) = 0;
  virtual jsi::Value isInitialized(jsi::Runtime &rt) = 0;

};

template <typename T>
class JSI_EXPORT NativeSpeechModuleCxxSpec : public TurboModule {
public:
  jsi::Value create(jsi::Runtime &rt, const jsi::PropNameID &propName) override {
    return delegate_.create(rt, propName);
  }

  std::vector<jsi::PropNameID> getPropertyNames(jsi::Runtime& runtime) override {
    return delegate_.getPropertyNames(runtime);
  }

  static constexpr std::string_view kModuleName = "SpeechModule";

protected:
  NativeSpeechModuleCxxSpec(std::shared_ptr<CallInvoker> jsInvoker)
    : TurboModule(std::string{NativeSpeechModuleCxxSpec::kModuleName}, jsInvoker),
      delegate_(reinterpret_cast<T*>(this), jsInvoker) {}


private:
  class Delegate : public NativeSpeechModuleCxxSpecJSI {
  public:
    Delegate(T *instance, std::shared_ptr<CallInvoker> jsInvoker) :
      NativeSpeechModuleCxxSpecJSI(std::move(jsInvoker)), instance_(instance) {

    }

    void addListener(jsi::Runtime &rt, jsi::String eventName) override {
      static_assert(
          bridging::getParameterCount(&T::addListener) == 2,
          "Expected addListener(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::addListener, jsInvoker_, instance_, std::move(eventName));
    }
    void removeListeners(jsi::Runtime &rt, double count) override {
      static_assert(
          bridging::getParameterCount(&T::removeListeners) == 2,
          "Expected removeListeners(...) to have 2 parameters");

      return bridging::callFromJs<void>(
          rt, &T::removeListeners, jsInvoker_, instance_, std::move(count));
    }
    jsi::Value requestSpeechRecognitionAuthorization(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::requestSpeechRecognitionAuthorization) == 1,
          "Expected requestSpeechRecognitionAuthorization(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::requestSpeechRecognitionAuthorization, jsInvoker_, instance_);
    }
    jsi::Value startRecognition(jsi::Runtime &rt, jsi::String locale, bool requiresOnDeviceRecognition) override {
      static_assert(
          bridging::getParameterCount(&T::startRecognition) == 3,
          "Expected startRecognition(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::startRecognition, jsInvoker_, instance_, std::move(locale), std::move(requiresOnDeviceRecognition));
    }
    jsi::Value stopRecognition(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::stopRecognition) == 1,
          "Expected stopRecognition(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::stopRecognition, jsInvoker_, instance_);
    }
    jsi::Value destroyRecognizer(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::destroyRecognizer) == 1,
          "Expected destroyRecognizer(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::destroyRecognizer, jsInvoker_, instance_);
    }
    jsi::Value isRecognitionAvailable(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::isRecognitionAvailable) == 1,
          "Expected isRecognitionAvailable(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::isRecognitionAvailable, jsInvoker_, instance_);
    }
    jsi::Value getSupportedLocales(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getSupportedLocales) == 1,
          "Expected getSupportedLocales(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getSupportedLocales, jsInvoker_, instance_);
    }
    jsi::Value getAvailableVoices(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getAvailableVoices) == 1,
          "Expected getAvailableVoices(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getAvailableVoices, jsInvoker_, instance_);
    }
    jsi::Value speak(jsi::Runtime &rt, jsi::String text, jsi::Object options) override {
      static_assert(
          bridging::getParameterCount(&T::speak) == 3,
          "Expected speak(...) to have 3 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::speak, jsInvoker_, instance_, std::move(text), std::move(options));
    }
    jsi::Value stopSpeaking(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::stopSpeaking) == 1,
          "Expected stopSpeaking(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::stopSpeaking, jsInvoker_, instance_);
    }
    jsi::Value pauseSpeaking(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::pauseSpeaking) == 1,
          "Expected pauseSpeaking(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::pauseSpeaking, jsInvoker_, instance_);
    }
    jsi::Value resumeSpeaking(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::resumeSpeaking) == 1,
          "Expected resumeSpeaking(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::resumeSpeaking, jsInvoker_, instance_);
    }
    jsi::Value isSpeaking(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::isSpeaking) == 1,
          "Expected isSpeaking(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::isSpeaking, jsInvoker_, instance_);
    }
    jsi::Value isPaused(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::isPaused) == 1,
          "Expected isPaused(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::isPaused, jsInvoker_, instance_);
    }
    jsi::Value setDefaultVoice(jsi::Runtime &rt, jsi::String voiceId) override {
      static_assert(
          bridging::getParameterCount(&T::setDefaultVoice) == 2,
          "Expected setDefaultVoice(...) to have 2 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::setDefaultVoice, jsInvoker_, instance_, std::move(voiceId));
    }
    jsi::Value configureAudioSession(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::configureAudioSession) == 1,
          "Expected configureAudioSession(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::configureAudioSession, jsInvoker_, instance_);
    }
    jsi::Value releaseAudioSession(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::releaseAudioSession) == 1,
          "Expected releaseAudioSession(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::releaseAudioSession, jsInvoker_, instance_);
    }
    jsi::Value getVersion(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::getVersion) == 1,
          "Expected getVersion(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::getVersion, jsInvoker_, instance_);
    }
    jsi::Value isInitialized(jsi::Runtime &rt) override {
      static_assert(
          bridging::getParameterCount(&T::isInitialized) == 1,
          "Expected isInitialized(...) to have 1 parameters");

      return bridging::callFromJs<jsi::Value>(
          rt, &T::isInitialized, jsInvoker_, instance_);
    }

  private:
    friend class NativeSpeechModuleCxxSpec;
    T *instance_;
  };

  Delegate delegate_;
};

} // namespace facebook::react
